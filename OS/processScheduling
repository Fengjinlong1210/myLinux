进程调度是操作系统中一个重要的功能, 它负责决定在多道程序环境下, 哪个进程将获得CPU时间片来执行。
进程调度涉及以下多个队列:
1. 就绪队列(Ready Queue)
    这是最常见的队列, 其中保存了已经准备好运行但还未获得CPU时间的所有进程。
    操作系统从就绪队列中选择下一个要运行的进程, 根据调度算法决定执行顺序。
2. 等待队列(Waiting Queue)
    也称阻塞队列, 通常存放为等待某种条件就绪或等待某种事件(例如IO、资源申请和释放)而暂时不能运行的队列
    一旦事件发生, 进程会从等待队列移动到就绪队列, 等待CPU调度执行。
3.后备队列(Job Queue):
    在批处理系统中可能会使用后备队列, 其中存放了用户提交的所有作业。
    操作系统根据某种策略, 从后备队列中选择要调度的作业, 并将其放入就绪队列。
4. 优先级队列:
    有些调度算法使用多个优先级队列，每个队列存放不同优先级的进程。
    操作系统可以根据进程的优先级，从相应的队列中进行选择。
5. 多级反馈队列:
    这是一种组合型队列，将进程分成多个优先级，每个优先级对应一个队列。
    进程初始进入较高优先级的队列，如果执行时间过长，可能会降低优先级，从而进入较低优先级的队列。

进程调度的目标包括：

1. 公平性
    为每个进程提供公平的CPU时间, 防止某个进程长时间占用CPU导致其他进程无法得到执行机会。
2. 响应时间
    尽量减少进程从提交到开始执行的时间，以提高系统对用户请求的响应速度。
3. 吞吐量
    最大化单位时间内完成的进程数量，提高系统整体的工作效率。
4. CPU利用率
    保持CPU的高利用率, 避免出现空闲或闲置状态。

操作系统使用各种调度算法来实现这些目标，常见的调度算法包括

1. 先来先服务(FCFS, First-Come-First-Served)
    按照进程到达的顺序分配CPU时间片, 适用于长作业的环境, 但可能导致短作业等待时间过长。
2. 最短作业优先(SJF, Shortest Job First) 平均等待事件最小
    优先调度估计执行时间最短的进程，以最小化平均等待时间，但可能导致长作业被饿死。
3. 优先级调度
    为每个进程分配优先级，优先级高的进程先执行。可以是静态优先级（进程提交时分配）或动态优先级（根据执行情况调整）。
4. 时间片轮转(RR,Round Robi)
    将CPU时间划分为固定大小的时间片, 每个进程轮流执行一个时间片, 适用于多用户环境。
5. 多级反馈队列调度
    将进程按优先级分为多个队列, 优先级高的队列分配更多时间片, 适用于兼顾短作业和长作业。


Linux中的进程调度算法
Linux操作系统使用多种进程调度算法来管理和调度进程，以实现多任务并发执行。
这些调度算法可以根据不同的场景和需求进行切换。以下是Linux中一些常见的进程调度算法：

CFS（Completely Fair Scheduler）： 
    CFS是Linux内核的默认进程调度算法，旨在提供公平的CPU时间分配。
    它通过维护进程的虚拟运行时间来决定下一个被调度执行的进程。CFS旨在避免饥饿和不公平对待任务。

Round Robin： 
    Round Robin是一种经典的时间片轮转调度算法，每个进程按照一定的时间片（通常是几毫秒）轮流执行。
    它简单且公平，但不适用于所有场景，特别是对于实时性要求较高的应用。

实时调度算法： 
    Linux支持多种实时调度算法，包括SCHED_FIFO和SCHED_RR。
    SCHED_FIFO按照优先级调度进程，直到进程主动释放CPU。SCHED_RR也是基于时间片的轮转调度，
    但可以设置进程的优先级。这些算法适用于对实时性有严格要求的应用，如嵌入式系统。

O(1)调度算法： 
    O(1)调度算法是早期Linux内核中使用的一种调度算法，它具有恒定的时间复杂度，不随进程数量的增加而增加。
    然而，随着多核处理器的普及，这种算法在性能上有一定局限性，因此在较新的内核中不再广泛使用。

CFS+： 
    CFS+是CFS的改进版本，引入了一些优化，以提高多核处理器上的性能。
    它旨在更好地利用多核系统的处理能力。

调度策略： 
    除了具体的调度算法，Linux还支持不同的调度策略，如SCHED_NORMAL（普通进程调度）、SCHED_BATCH（批处理进程调度）和SCHED_IDLE（空闲进程调度）。
    每种策略都适用于不同类型的任务和场景。

总之，Linux中有多种进程调度算法和策略可供选择，以满足不同应用的需求。
默认情况下，CFS是Linux内核的主要进程调度算法，但可以根据具体需求进行配置和切换。
这种灵活性使得Linux能够在各种应用场景中提供高效的任务调度和资源管理。

/////////////////////////////////////

设计模式是在软件设计和开发中经常遇到的常见问题的解决方案的通用模板或蓝图。它们是从经验中总结出来的，并提供了在特定情境下构建可维护、可扩展、可复用的软件的指导原则。设计模式有助于提高代码的可读性、可维护性和可扩展性，并促进了团队之间的共享和理解。

以下是一些常见的设计模式：

单例模式（Singleton Pattern）： 单例模式确保一个类只有一个实例，并提供一个全局访问点。这对于需要在整个应用程序中共享某个资源的情况非常有用，例如配置管理、数据库连接池等。

工厂模式（Factory Pattern）： 工厂模式定义一个接口，然后由子类来决定实例化哪个具体类。这有助于将对象的创建与其使用分离开来，使系统更加灵活。

抽象工厂模式（Abstract Factory Pattern）： 抽象工厂模式提供一个接口，用于创建一系列相关或依赖对象的族群，而不需要指定具体类。它通常用于创建一组相关的产品对象，例如创建不同操作系统上的界面元素。

建造者模式（Builder Pattern）： 建造者模式用于创建一个复杂对象，通过一系列简单的步骤或方法来构建。这有助于解耦对象的构建过程和表示。

原型模式（Prototype Pattern）： 原型模式用于创建对象的新实例，通过复制现有对象的属性，而不是使用构造函数。这对于创建成本高昂或复杂的对象非常有用。

适配器模式（Adapter Pattern）： 适配器模式用于将一个类的接口转换成客户端所期望的接口，从而使不兼容的接口能够一起工作。

装饰器模式（Decorator Pattern）： 装饰器模式用于动态地将责任附加到对象上。它允许你不修改原始类的情况下扩展对象的功能。

观察者模式（Observer Pattern）： 观察者模式定义了一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都会收到通知并自动更新。

策略模式（Strategy Pattern）： 策略模式定义了一系列算法，将它们封装成对象，并使它们可以相互替换。这允许客户端根据需要动态地选择算法。

模板方法模式（Template Method Pattern）： 模板方法模式定义了一个算法的骨架，将算法的一些步骤延迟到子类中实现。这有助于避免代码重复，并允许子类定制算法的特定部分。

这只是一些常见的设计模式，实际上还有更多的模式，每个模式都有其适用的场景和优点。设计模式是面向对象编程中的重要概念，有助于提高代码的质量、可维护性和可复用性。选择合适的设计模式可以根据具体需求提供清晰的解决方案，并促使开发者更好地组织和理解代码。
